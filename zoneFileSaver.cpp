#include "zoneFileSaver.h"
#include "zone.h"
#include "acl.h"
#include "rr.h"
#include "rrsoa.h"
#include "tsig.h"
#include <fstream>
#include <sstream>
#include <ctime>
#include <cstring>

using namespace std;

bool ZoneFileSaver::saveToFile(Zone* zone, const string& filename)
{
	if (filename.empty())
	{
		cerr << "Zone " << zone->name << ": Cannot save, no filename specified" << endl;
		return false;
	}
	
	// Create backup of existing file
	string backup_name = filename + ".bak";
	ifstream test_existing(filename.c_str());
	if (test_existing.good())
	{
		test_existing.close();
		remove(backup_name.c_str());
		rename(filename.c_str(), backup_name.c_str());
	}
	
	ofstream out(filename.c_str());
	if (!out.good())
	{
		cerr << "Zone " << zone->name << ": Failed to open file for writing: " << filename << endl;
		rename(backup_name.c_str(), filename.c_str());
		return false;
	}
	
	serialize(zone, out);
	
	out.close();
	
	if (!out.good())
	{
		cerr << "Zone " << zone->name << ": Error writing to file: " << filename << endl;
		rename(backup_name.c_str(), filename.c_str());
		return false;
	}
	
	// Clear modified flag after successful save
	zone->clearModified();
	
	cerr << "Zone " << zone->name << ": Successfully saved to " << filename << endl;
	return true;
}

void ZoneFileSaver::serialize(const Zone* zone, ostream& out, bool include_header)
{
	if (include_header)
	{
		writeHeader(out, zone);
		writeDirectives(out, zone, true);  // Include $ORIGIN for main zone
	}
	else
	{
		writeDirectives(out, zone, false);  // No $ORIGIN for ACL sub-zones
	}
	writeRecords(out, zone);
	writeACLs(out, zone);
}

void ZoneFileSaver::writeHeader(ostream& out, const Zone* zone)
{
	time_t now = time(NULL);
	char timebuf[64];
	strftime(timebuf, sizeof(timebuf), "%Y-%m-%d %H:%M:%S", localtime(&now));
	
	out << "; Zone file for " << zone->name << endl;
	out << "; Auto-generated by dnsserver" << endl;
	out << "; Last updated: " << timebuf << endl;
	out << endl;
}

void ZoneFileSaver::writeDirectives(ostream& out, const Zone* zone, bool include_origin)
{
	// Write $ORIGIN only if requested (not for ACL sub-zones)
	if (include_origin)
	{
		out << "$ORIGIN " << zone->name << endl;
	}
	
	// Write $AUTOSAVE if enabled
	if (zone->auto_save)
	{
		out << "$AUTOSAVE yes" << endl;
	}
	
	// Write $TSIG if present
	if (zone->tsig_key)
	{
		out << "$TSIG " << zone->tsig_key->name << " "
		    << TSIG::algorithmToName(zone->tsig_key->algorithm) << " "
		    << zone->tsig_key->secret << endl;
	}
	
	out << endl;
}

void ZoneFileSaver::writeACLs(ostream& out, const Zone* zone)
{
	// Write ACL sub-zones with $ACL headers
	if (zone->acl && zone->acl->size() > 0)
	{
		const vector<Acl::AclEntry>& entries = zone->acl->getEntries();
		
		for (vector<Acl::AclEntry>::const_iterator it = entries.begin(); it != entries.end(); ++it)
		{
			// Only write ACL entry if it has records
			if (it->zone && it->zone->getAllRecords().size() > 0)
			{
				out << endl << "$ACL " << it->subnet.toString() << endl;
				
				// Serialize the ACL sub-zone (without header)
				serialize(it->zone, out, false);
			}
		}
	}
}

void ZoneFileSaver::writeRecords(ostream& out, const Zone* zone)
{
	const vector<RR*>& records = zone->getAllRecords();
	
	// First write SOA
	for (vector<RR*>::const_iterator it = records.begin(); it != records.end(); ++it)
	{
		RR* rr = *it;
		if (rr->type == RR::SOA)
		{
			out << rr->toString() << endl;
		}
	}
	
	// Then write NS records
	for (vector<RR*>::const_iterator it = records.begin(); it != records.end(); ++it)
	{
		RR* rr = *it;
		if (rr->type == RR::NS)
		{
			out << rr->toString() << endl;
		}
	}
	
	out << endl;
	
	// Then write all other records grouped by name
	string last_name;
	for (vector<RR*>::const_iterator it = records.begin(); it != records.end(); ++it)
	{
		RR* rr = *it;
		
		// Skip SOA and NS (already written)
		if (rr->type == RR::SOA || rr->type == RR::NS)
			continue;
		
		// Add blank line between different names
		if (!last_name.empty() && rr->name != last_name)
			out << endl;
		
		out << rr->toString() << endl;
		last_name = rr->name;
	}
}
